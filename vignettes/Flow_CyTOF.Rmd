---
title: "Integrating paired flow cytometry and CyTOF data"
author: "Christina Bligaard Pedersen"
date: "January 26, 2021"
output:
  html_document:
    df_print: paged
---


<br><br>

This vignette will demonstrate the integration of paired flow cytometry and CyTOF protein expression measurements using cyCombine.

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

knitr::opts_knit$set(root.dir = '/home/projects/dp_immunoth/people/s134891/cycombine/flow_cytof/')

```



<br><br>
First, let us present the datasets we will integrate:

These datasets are from the article by [Oetjen et al. (2018)](https://doi.org/10.1172/jci.insight.124928). The data is from bone marrow aspirations from healthy donors. Originally, five flow cytometry panels were applied on 20 donors, and a mass cytometry panel was used for 8 of these samples.

We downloaded the FCS files for the 8 CyTOF samples and the T cell flow cytometry panel (the 8 paired donors) from FlowRepository (FR-FCM-ZYQ9, FR-FCM-ZYQB). Both datasets were pre-gated to live, intact singlet cells and exported as FCS files.

<br><br>

#### Preparing data

We start by loading some packages.

```{r libraries, results = 'hide', warning=FALSE, message=FALSE}
library(cyCombine)
library(tidyverse)
library(Seurat)

```


<br><br>

We are now ready to load the flow data. We have set up a panel file in csv format, so the correct information is extractable from there. Let us have a look at the contents:

```{r loading flow data 1}
# Directory with raw .fcs files
data_dir <- "Oetjen_et_al_2018-Singlet-Live"

# Panel and reading data
flow_panel <- read_csv('flow_panel_T.csv')
flow_panel
```

<br><br>

We then progress with reading the flow dataset and converting it to a tibble format, which is easy to process. We use cofactor = 150 for flow cytometry data asinh-transformation.


```{r loading flow data 2}
flow_markers <- flow_panel %>% 
  filter(Type != "none") %>% 
  pull(Marker) %>% 
  str_remove_all("[ _-]")

flow <- prepare_data(data_dir = data_dir,
                         metadata = "metadata.xlsx",
                         filename_col = "FileName_T",
                         batch_ids = "Batch",
                         cofactor = 150,
                         sample_ids = 'SampleID',
                         markers = flow_markers,
                         down_sample = FALSE)

# We get rid of any negative values in the flow data using a linear shift - essentially these don't matter but it makes sense because cyCombine uses a cap of 0 for batch correction
flow <- linear_shift(flow, .keep = T)

```


<br><br>

Then it is time to read the CyTOF data.

```{r cytof read}
# Directory with raw .fcs files
data_dir <- "Oetjen_et_al_2018_CyTOF"

# Panel and reading data
cytof_panel <- read_csv('cytof_panel.csv')

cytof_markers <- cytof_panel %>% 
  filter(Type != "none") %>% 
  pull(Marker) %>% 
  str_remove_all("[ _-]")

cytof <- prepare_data(data_dir = data_dir,
                      metadata = "metadata.xlsx",
                      filename_col = "FileName_T",
                      batch_ids = "Batch",
                      cofactor = 5,
                      sample_ids = 'SampleID',
                      markers = cytof_markers,
                      down_sample = FALSE)



```


<br><br>

#### Processing data together - batch correction

Next, we need to figure out which markers to use when integrating the two datasets. 

Be careful with protein names - I.e. in CyTOF, the column name is CD95FAS - in flow it is CD95.

```{r overlapping markers}
colnames(cytof)[colnames(cytof)=='CD95FAS'] <- 'CD95'
colnames(cytof)[colnames(cytof)=='CD8a'] <- 'CD8'
colnames(cytof)[colnames(cytof)=='CD197'] <- 'CCR7'

```

<br><br>

Now, we are ready to combine the two datasets on the overlapping columns.

```{r combine sets}
# Get overlapping column names
overlap_cols <- intersect(colnames(flow), colnames(cytof))

# Make one tibble
uncorrected <- bind_rows(cytof[,overlap_cols], flow[,overlap_cols]) %>%
  mutate(id = 1:(nrow(cytof)+nrow(flow)))

```

And now, batch correction can be performed with cyCombine.

```{r batch correction, message=FALSE, warning=FALSE, error=FALSE, results='hide'}
# Run batch correction
corrected <- uncorrected %>%
  batch_correct(xdim = 8,
                ydim = 8,
                norm_method = 'rank',
                ties.method = 'average')

# Add manually assigned labels back
# corrected$label <- uncorrected$label

```

<br><br>

#### Evaluating performance

We now evaluate the correction using EMD - each marker is evaluated across all cells.

```{r global emd, message=FALSE, fig.height=4, fig.width=4}
corrected$label <- uncorrected$label <- 1

emd <- evaluate_emd(preprocessed = uncorrected,
             corrected = corrected)

emd$violin
emd$scatterplot
```

Finally, let us look at some plots to visualize the correction. First, the marker distributions before and after:

```{r density plot, message=FALSE, fig.height=8, fig.width=16}
plot_density(uncorrected, corrected)

```

<br><br>

Finally, some UMAPs to visualize the correction. I will downsample to 10,000 cells from each dataset so it is easier to see what is going on.

```{r umaps, fig.height=6, fig.width=6}
inds <- split(1:length(uncorrected$batch), uncorrected$batch)
sample <- unlist(lapply(inds, sample, 10000))

plot1 <- plot_dimred(uncorrected[sample,], name = 'Uncorrected', type = 'umap')
plot2 <- plot_dimred(corrected[sample,], name = 'Corrected', type = 'umap')

plot1
plot2
```

Based on the UMAP, it seems like the datasets each contain three major clusters. This is also the case after correction.


<br><br>

Since we actually have paired samples in this dataset, it is possible to make a direct comparison - first we will co-cluster the data using FlowSOM.


```{r coclustering}
# Clustering with 3x3 SOM grid 
som_ <- corrected %>%
  cyCombine::create_som(seed = 48,
                        xdim = 3,
                        ydim = 3)

# Saving labels
corrected$label <- as.factor(som_)
```


<br> 

Now, let us have a look at the clusters and their expression patterns.

```{r marker umaps}
plots <- plot_dimred(corrected[sample,], name = 'Corrected', type = 'umap', plot = 'CD3', return_coord = T)


# We can further include the UMAP coordinates in a combined dataframe with both imputed datasets. Again, we downsample to avoid too many cells cluttering the view (the same indeces are used as before)
combined <- cbind.data.frame(plots$dimred, corrected[sample,])


# Now let us color the plot by the relatively few overlapping markers - and the cluster labels
p <- list()
for (m in c(get_markers(corrected))) {
  
  p[[m]] <- ggplot(combined, aes_string(x = colnames(combined)[1], y = colnames(combined)[2])) +
  geom_point(aes_string(color = m), alpha = 0.3, size = 0.4) +
  theme_bw() + theme(plot.title = element_text(hjust = 0.5)) + 
  scale_color_viridis_c()

}

ggplot(combined, aes_string(x = colnames(combined)[1], y = colnames(combined)[2])) +
  geom_point(aes(color = label), alpha = 0.3, size = 0.4) +
  theme_bw() + theme(plot.title = element_text(hjust = 0.5))

```


```{r marker umaps 2}
cowplot::plot_grid(plotlist = p, ncol = 3)

```






```{r coclustering visualization}
# Comparing SOM percentages in paired samples
count_table <- table(corrected$sample, corrected$label)

round((count_table/rowSums(count_table)) * 100, 2)

```

Here, it is seen that the sample cell type fractions correlate nicely with the counterpart from the other technology. 







